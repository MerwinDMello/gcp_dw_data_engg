#!/bin/ksh
# *****************************************************************************
#  
# Copyright (c) @@CURRENT_YEAR Syncsort Inc.
#
# This file contains proprietary and confidential material, and is only for use
# by the lessees of the DMExpress proprietary software system.
#
#
# KornShell job script generated by DMExpress
#   
# Version: 9.7.0
# Date:    Friday, February 14, 2020 3:19:54 PM
# Note:
# 1.       In order to run this job script from the command line, execute the
#          command:
#
#              dmxjob /run job_name.dxj
#
#          where "job_name.dxj" is the name of this file.
#
# 2.       You must have Korn Shell (ksh) installed.
#
# 3.       You may customize portions of the script to add custom steps to the
#          job.
#
# 4.       If you run this script from the command line, DMExpress messages
#          are sent to standard error by default.
#
# 5.       If you run this job script from another script, the parent script
#          should start dmxjob in a separate process group. In Korn Shell
#          this can be done as follows:
#
#              set -m
#              dmxjob /run job_name.dxj &
#              set +m
#              wait $!
#
#          This will prevent the parent script from being killed if an error
#          occurs and the DMExpress job script must clean up. For more
#          information, consult the documentation for your shell.
#
# *****************************************************************************

# Import DMExpress shell functions
. DMExpress.ksh

# Save a copy of the process PATH
savedProcessPath=$PATH

WaitForTask()
{
    # ************************************************************************
    # PURPOSE:
    # This routine waits for a given task to finish.
    # ************************************************************************
    typeset task=$1
    while [ ! -f "$tempDir/$$_${jobName}_task$task.exit" ]
    do
        sleep 1
    done
}

WriteExitStatus()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the exit status of a task to a temporary file.
    # ************************************************************************
    typeset task=$1
    typeset status=$2
    if [[ $status -eq 111 ]]
    then
        touch "$tempDir/$$_${jobName}_job.abort"
    fi
    echo $status > $tempDir/$$_${jobName}_task$task.exit
}

WriteTaskHeader()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the task header text.
    # ************************************************************************
    typeset taskTitle="$1"
    echo "" 1>&2
    echo "************************ BEGIN TASK $taskTitle ************************" 1>&2
}

WriteTaskFooter()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the task footer text.
    # ************************************************************************
    typeset taskTitle="$1"
    echo "************************ END TASK $taskTitle   ************************" 1>&2
}

CreateNamedPipe()
{
    # ************************************************************************
    # PURPOSE:
    # This routine creates a named pipe if it does not already exist.
    # ************************************************************************
    typeset pipeName="$1"
    mknod "$pipeName" p 2>/dev/null || \
    mkfifo "$pipeName" 2>/dev/null
    if [[ $? -eq 0 ]]
    then
        return 1
    else
        return 0
    fi
}

CreateTemporaryNamedPipe()
{
    # ************************************************************************
    # PURPOSE:
    # This routine creates a named pipe
    # ************************************************************************
    typeset pipeName="$1"
    mknod "$pipeName" p 2>/dev/null || \
    mkfifo "$pipeName" 2>/dev/null || \
    ( echo "Could not create named pipe $pipeName" 1>&2 ; \
      touch "$tempDir/$$_${jobName}_job.abort" )
}

ConnectInput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input of a DMExpress task
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
        if [[ $? -eq 111 ]]
        then
            echo "DMXGetStandardInputIndex call failed" 1>&2
            return $?
        fi
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Previous task $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectInputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input file of a DMExpress task as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Input file $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectJoinedInput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input of a DMExpress task that is a join
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex

    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetStandardInputIndex call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetStandardInputIndex call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    echo "Previous task $connectionLabel not found in task" 1>&2
    return 111
}

ConnectJoinedInputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input file of a DMExpress task that is a join
    # as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex

    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    echo "Inputfile $connectionLabel not found in task" 1>&2
    return 111
}

ConnectOutput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an output of a DMExpress task
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetFollowingTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetFollowingTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        connectionIndex=`DMXGetStandardOutputIndex $applicationID 2>/dev/null`
        if [[ $? -eq 111 ]]
        then
            echo "DMXGetStandardOutputIndex call failed" 1>&2
            return $?
        fi
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Following task $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetTargetFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectOutputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an output file of a DMExpress task as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetOutputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetOutputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Output file $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetTargetFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ExecuteJob_1()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes job AC_REL_TD_EXP.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the job.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task1.temp"

    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 1 111 ; return
    fi

    
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task1.temp" 1>&2
        WriteTaskFooter "AC_REL_TD_EXP" ; WriteExitStatus 1 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the job here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_JOB_CUSTOM JOB=PREJOB_CUSTOM_1

    # @@END DMEXPRESS_PRE_JOB_CUSTOM

    
    # Execute DMX job
    exitCode=0
    dmxjob /RUN "$DMXJobDirectory/../../SharedJobs/AC_REL_TD_EXP/AC_REL_TD_EXP.dxj"
    exitCode=$?

    # TO DO: Insert the custom steps to be executed after executing the job here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_JOB_CUSTOM JOB=POSTJOB_CUSTOM_1

    # @@END DMEXPRESS_POST_JOB_CUSTOM 
   

    WriteExitStatus 1 $exitCode
}

ExecuteTask_2()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes task Core Table Load.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the task.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task2.temp"

    WaitForTask 1
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 2 111 ; return
    fi

    
    WriteTaskHeader "Core Table Load"
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task2.temp" 1>&2
        WriteTaskFooter "Core Table Load" ; WriteExitStatus 2 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the task here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_TASK_CUSTOM TASK=PRETASK_CUSTOM_2

    # @@END DMEXPRESS_PRE_TASK_CUSTOM

    
    # Prepend the job directory to the process environment PATH
    PATH=$DMXJobDirectory:$PATH
    export PATH

    # Run custom task command
    exitCode=0
    "$SCRIPTDIR/ETL_BTEQ_Runner.sh" HDW_Development_Activity_Load.sql

    # Save exit status of the custom task
    CUSTOM_TASK_RETURN_CODE=$?

    # Check if the return code of the custom command denotes success
    if [ "$CUSTOM_TASK_RETURN_CODE" -eq 0 ]
    then
        typeset timestamp=`date +"%m/%d/%Y %H:%M:%S"`
        echo "$timestamp - Custom task has completed successfully with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
    else
        echo "Custom task has failed with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
        exitCode=111
    fi
    
    # Restore the saved value of the process environment PATH
    PATH=$savedProcessPath
    export PATH

    # TO DO: Insert the custom steps to be executed after executing the task here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_TASK_CUSTOM TASK=POSTTASK_CUSTOM_2

    # @@END DMEXPRESS_POST_TASK_CUSTOM 
   

    WriteTaskFooter "Core Table Load"
    WriteExitStatus 2 $exitCode
}

ExecuteJob_3()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes job AC_REL_TD_ACT.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the job.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task3.temp"

    WaitForTask 2
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 3 111 ; return
    fi

    
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task3.temp" 1>&2
        WriteTaskFooter "AC_REL_TD_ACT" ; WriteExitStatus 3 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the job here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_JOB_CUSTOM JOB=PREJOB_CUSTOM_3

    # @@END DMEXPRESS_PRE_JOB_CUSTOM

    
    # Execute DMX job
    exitCode=0
    dmxjob /RUN "$DMXJobDirectory/../../SharedJobs/AC_REL_TD_ACT/AC_REL_TD_ACT.dxj"
    exitCode=$?

    # TO DO: Insert the custom steps to be executed after executing the job here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_JOB_CUSTOM JOB=POSTJOB_CUSTOM_3

    # @@END DMEXPRESS_POST_JOB_CUSTOM 
   

    WriteExitStatus 3 $exitCode
}

WaitForAllTasks()
{
    # ************************************************************************
    # PURPOSE:
    # This routine waits for all tasks to finish, writes their output to
    # standard error and returns the most severe exit status.
    # ************************************************************************
    typeset mostSevereError=0
    typeset keepLooping=1
    typeset task
    typeset exitStatus
    while [[ $keepLooping -eq 1 ]]
    do
        sleep 1
        keepLooping=0
        task=1
        while [[ $task -le 3 ]]
        do
            if [ -f "$tempDir/$$_${jobName}_task$task.exit" ]
            then
                if [ ! -f "$tempDir/$$_${jobName}_task$task.written" ]
                then
                    cat "$tempDir/$$_${jobName}_task$task.out" 1>&2
                    exitStatus=`cat "$tempDir/$$_${jobName}_task$task.exit"`
                    GetMostSevereError $mostSevereError $exitStatus
                    mostSevereError=$?
                    touch "$tempDir/$$_${jobName}_task$task.written"
                    if [[ $exitStatus -eq 111 ]]
                    then
                        kill -TERM 0
                    fi
                fi
            else
                if [ -f "$tempDir/$$_${jobName}_job.abort" ]
                then
                    if [ -f "$tempDir/$$_${jobName}_task$task.temp" ]
                    then
                        keepLooping=1
                    fi
                else
                    keepLooping=1
                fi
            fi
            ((task=$task+1))
        done
    done
    return $mostSevereError
}

GetMostSevereError()
{
    # ************************************************************************
    # PURPOSE:
    # This routine gets the most severe error out of the 2 DMExpress exit
    # status passed.
    # ************************************************************************
    status1=$1
    status2=$2
    if [[ $status1 -gt $status2 ]]
    then
        return $status1
    else
        return $status2
    fi
}

CleanUp()
{
    # ************************************************************************
    # PURPOSE:
    # To clean up temporary resources used by the job
    # ************************************************************************
    typeset tempDir=$1
    rm -f "$tempDir/$$_${jobName}_job.abort"
    rm -f "$tempDir/$$_${jobName}_task1.exit"
    rm -f "$tempDir/$$_${jobName}_task1.out"
    rm -f "$tempDir/$$_${jobName}_task1.written"
    rm -f "$tempDir/$$_${jobName}_task1.temp"
    rm -f "$tempDir/$$_${jobName}_task2.exit"
    rm -f "$tempDir/$$_${jobName}_task2.out"
    rm -f "$tempDir/$$_${jobName}_task2.written"
    rm -f "$tempDir/$$_${jobName}_task2.temp"
    rm -f "$tempDir/$$_${jobName}_task3.exit"
    rm -f "$tempDir/$$_${jobName}_task3.out"
    rm -f "$tempDir/$$_${jobName}_task3.written"
    rm -f "$tempDir/$$_${jobName}_task3.temp"
}


# ************************************************************************
# PURPOSE:
# The main routine that executes the job.
# 
# TO DO:
# Modify this function as indicated in the body of the script to add 
# custom steps that should be executed before and after the execution 
# of the job.
# ************************************************************************

# Job name
jobName=`basename "$0" | cut -f -1 -d .`

# Temporary directory
tempDir=`DMXGetTempDir`
CleanUp $tempDir

# Trap signals and do clean-up
trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM


# TO DO: Insert the custom steps to be executed prior to running the job 
# between the @@START and @@END blocks
# @@START DMEXPRESS_PRE_JOB_CUSTOM

# @@END DMEXPRESS_PRE_JOB_CUSTOM

# Create temporary named pipes

# Create user-specified named pipes if they do not exist

# Start in parallel
ExecuteJob_1 2> $tempDir/$$_${jobName}_task1.out 1>&2 & \
ExecuteTask_2 2> $tempDir/$$_${jobName}_task2.out 1>&2 & \
ExecuteJob_3 2> $tempDir/$$_${jobName}_task3.out 1>&2 & \

# Wait for tasks to finish
WaitForAllTasks
mostSevereError=$?
if [ -f "$tempDir/$$_${jobName}_job.abort" ]
then
    mostSevereError=111
fi

# TO DO: Insert the custom steps to be executed after running the job 
# between the @@START and @@END blocks
# @@START DMEXPRESS_POST_JOB_CUSTOM

# @@END DMEXPRESS_POST_JOB_CUSTOM

# Free resources
wait
CleanUp $tempDir

# Return most severe error 
exit $mostSevereError



#***********************************************************************************
# Important Note: The following lines are used by DMExpress to store job specific 
# information. Do NOT delete or modify this section as it is exclusively used by 
# DMExpress.
# @@START DMEXPRESS_JOBEDITOR_APPSTREAM
#Version=8
#Release=9.7.0
#Language=kornshellscript
#Data=1x2p8d2w87yeinbffzvbvze6wxixmr6ry4mz6zhzxcw06w4zu7r2910fcjja1wknkv3r20btfvjaxprde0wza4xn6y3ynvt22nc1f0tjzavyc46yv295w4fww9ndbipcehc71r38jud2zjzs51s3j71eauna0ezwe8f9sf1u23xcbut13k3xpe20n3j50jhv2d7t985dcan2trcbsyfa9pbxctcn651ccu8z79f6ydjzji7aw42p9frt9i55vt2vpmcvwiwxiyt7e0bvh1ejk34zkait03rd3ssyf6rj8v6mz6r43erz1919zeapk890dd3vhxhmv2751mwisy9ppt9e41pmj4fer5k0jxw7u11364epxkbf0mubb0wik51nvyek6ru5y7646bzfxif5ndn5whn22um34h9sjhpw395c1rmkzez60zi3tzb151xtky2kz0j7hjjnsieupd90ip73u08beia92w9zrhu246x9echrihf7p5ku5piv2y0kkukd5n6cmkfneahwwhi9342i4h642h0ruh3pm6iarmj504mvykupzd0hr3chs65eba6edvccb9ijh4fe848hw3uzcbmumhkd1883u9amdw0kevfmt7biwtz49ktuwpwevjx490ft5pscfinhzh1bacd1zpx76zsnd542j7586shahmim48k0wz7utp7836rmaebmrcxaeacdtpspa9t0vjf8xsjdcskvfssvupc8u2wasyeiy1cvfkyn6abr2i0dkrbbdzah03pi74fh8ftkbyfxk3v6hj3jsb2k8jxyh0xtyezus5fzv3wmdfchztweu0vd92a7d9vjrtiwa2ei37k6zrbdaunxdpvpc6rekef1we8e5jr4877tvbvm79dfbv0h6zi4tkkhb4ry0h2294ty62fuzkxkn1f77km8s2m0jkeyrdsejx2z19371rhcchiz6fr6iij5ibxnnjd3nzvmedt2i082fuxjk6nmuw1fxw8uasky0p22c7u4ifrcw2cwk8c6ucwhkp5dx0dr71ph1453y34u677vmnw8kv6n9sz55i5ibp9mm9c0bhxsi594au5e7xwcvyjzyv7tatz78iw270iay00ittmmv3vcwyh8rnm0mm16r150ujdrsr1jydtx5c9j0zjdsyx3irmfzubkhh59rj4ahsippphpzudtwsf0a
# @@END DMEXPRESS_JOBEDITOR_APPSTREAM
#***********************************************************************************

