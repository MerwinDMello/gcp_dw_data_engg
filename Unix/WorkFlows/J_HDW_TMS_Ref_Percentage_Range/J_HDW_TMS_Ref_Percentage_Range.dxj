#!/bin/ksh
# *****************************************************************************
#  
# Copyright (c) @@CURRENT_YEAR Syncsort Inc.
#
# This file contains proprietary and confidential material, and is only for use
# by the lessees of the DMExpress proprietary software system.
#
#
# KornShell job script generated by DMExpress
#   
# Version: 9.0.0
# Date:    Monday, October 10, 2016 12:24:48 AM
# Note:
# 1.       In order to run this job script from the command line, execute the
#          command:
#
#              dmxjob /run job_name.dxj
#
#          where "job_name.dxj" is the name of this file.
#
# 2.       You must have Korn Shell (ksh) installed.
#
# 3.       You may customize portions of the script to add custom steps to the
#          job.
#
# 4.       If you run this script from the command line, DMExpress messages
#          are sent to standard error by default.
#
# 5.       If you run this job script from another script, the parent script
#          should start dmxjob in a separate process group. In Korn Shell
#          this can be done as follows:
#
#              set -m
#              dmxjob /run job_name.dxj &
#              set +m
#              wait $!
#
#          This will prevent the parent script from being killed if an error
#          occurs and the DMExpress job script must clean up. For more
#          information, consult the documentation for your shell.
#
# *****************************************************************************

# Import DMExpress shell functions
. DMExpress.ksh

# Save a copy of the process PATH
savedProcessPath=$PATH

WaitForTask()
{
    # ************************************************************************
    # PURPOSE:
    # This routine waits for a given task to finish.
    # ************************************************************************
    typeset task=$1
    while [ ! -f "$tempDir/$$_${jobName}_task$task.exit" ]
    do
        sleep 1
    done
}

WriteExitStatus()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the exit status of a task to a temporary file.
    # ************************************************************************
    typeset task=$1
    typeset status=$2
    if [[ $status -eq 111 ]]
    then
        touch "$tempDir/$$_${jobName}_job.abort"
    fi
    echo $status > $tempDir/$$_${jobName}_task$task.exit
}

WriteTaskHeader()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the task header text.
    # ************************************************************************
    typeset taskTitle="$1"
    echo "" 1>&2
    echo "************************ BEGIN TASK $taskTitle ************************" 1>&2
}

WriteTaskFooter()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the task footer text.
    # ************************************************************************
    typeset taskTitle="$1"
    echo "************************ END TASK $taskTitle   ************************" 1>&2
}

CreateNamedPipe()
{
    # ************************************************************************
    # PURPOSE:
    # This routine creates a named pipe if it does not already exist.
    # ************************************************************************
    typeset pipeName="$1"
    mknod "$pipeName" p 2>/dev/null || \
    mkfifo "$pipeName" 2>/dev/null
    if [[ $? -eq 0 ]]
    then
        return 1
    else
        return 0
    fi
}

CreateTemporaryNamedPipe()
{
    # ************************************************************************
    # PURPOSE:
    # This routine creates a named pipe
    # ************************************************************************
    typeset pipeName="$1"
    mknod "$pipeName" p 2>/dev/null || \
    mkfifo "$pipeName" 2>/dev/null || \
    ( echo "Could not create named pipe $pipeName" 1>&2 ; \
      touch "$tempDir/$$_${jobName}_job.abort" )
}

ConnectInput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input of a DMExpress task
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
        if [[ $? -eq 111 ]]
        then
            echo "DMXGetStandardInputIndex call failed" 1>&2
            return $?
        fi
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Previous task $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectInputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input file of a DMExpress task as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Input file $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectJoinedInput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input of a DMExpress task that is a join
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex

    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetStandardInputIndex call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetStandardInputIndex call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    echo "Previous task $connectionLabel not found in task" 1>&2
    return 111
}

ConnectJoinedInputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input file of a DMExpress task that is a join
    # as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex

    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    echo "Inputfile $connectionLabel not found in task" 1>&2
    return 111
}

ConnectOutput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an output of a DMExpress task
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetFollowingTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetFollowingTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        connectionIndex=`DMXGetStandardOutputIndex $applicationID 2>/dev/null`
        if [[ $? -eq 111 ]]
        then
            echo "DMXGetStandardOutputIndex call failed" 1>&2
            return $?
        fi
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Following task $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetTargetFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectOutputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an output file of a DMExpress task as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetOutputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetOutputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Output file $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetTargetFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ExecuteJob_1()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes job AC_REL_TD_EXP.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the job.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task1.temp"

    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 1 111 ; return
    fi

    
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task1.temp" 1>&2
        WriteTaskFooter "AC_REL_TD_EXP" ; WriteExitStatus 1 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the job here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_JOB_CUSTOM JOB=PREJOB_CUSTOM_1

    # @@END DMEXPRESS_PRE_JOB_CUSTOM

    
    # Execute DMX job
    exitCode=0
    dmxjob /RUN "$DMXJobDirectory/../../SharedJobs/AC_REL_TD_EXP/AC_REL_TD_EXP.dxj"
    exitCode=$?

    # TO DO: Insert the custom steps to be executed after executing the job here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_JOB_CUSTOM JOB=POSTJOB_CUSTOM_1

    # @@END DMEXPRESS_POST_JOB_CUSTOM 
   

    WriteExitStatus 1 $exitCode
}

ExecuteTask_2()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes task Core Table Load.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the task.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task2.temp"

    WaitForTask 1
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 2 111 ; return
    fi

    
    WriteTaskHeader "Core Table Load"
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task2.temp" 1>&2
        WriteTaskFooter "Core Table Load" ; WriteExitStatus 2 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the task here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_TASK_CUSTOM TASK=PRETASK_CUSTOM_2

    # @@END DMEXPRESS_PRE_TASK_CUSTOM

    
    # Prepend the job directory to the process environment PATH
    PATH=$DMXJobDirectory:$PATH
    export PATH

    # Run custom task command
    exitCode=0
    "$SCRIPTDIR/ETL_BTEQ_Runner.sh" HDW_Ref_Percentage_Range_Load.sql

    # Save exit status of the custom task
    CUSTOM_TASK_RETURN_CODE=$?

    # Check if the return code of the custom command denotes success
    if [ "$CUSTOM_TASK_RETURN_CODE" -eq 0 ]
    then
        typeset timestamp=`date +"%m/%d/%Y %H:%M:%S"`
        echo "$timestamp - Custom task has completed successfully with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
    else
        echo "Custom task has failed with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
        exitCode=111
    fi
    
    # Restore the saved value of the process environment PATH
    PATH=$savedProcessPath
    export PATH

    # TO DO: Insert the custom steps to be executed after executing the task here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_TASK_CUSTOM TASK=POSTTASK_CUSTOM_2

    # @@END DMEXPRESS_POST_TASK_CUSTOM 
   

    WriteTaskFooter "Core Table Load"
    WriteExitStatus 2 $exitCode
}

ExecuteJob_3()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes job AC_REL_TD_ACT.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the job.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task3.temp"

    WaitForTask 2
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 3 111 ; return
    fi

    
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task3.temp" 1>&2
        WriteTaskFooter "AC_REL_TD_ACT" ; WriteExitStatus 3 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the job here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_JOB_CUSTOM JOB=PREJOB_CUSTOM_3

    # @@END DMEXPRESS_PRE_JOB_CUSTOM

    
    # Execute DMX job
    exitCode=0
    dmxjob /RUN "$DMXJobDirectory/../../SharedJobs/AC_REL_TD_ACT/AC_REL_TD_ACT.dxj"
    exitCode=$?

    # TO DO: Insert the custom steps to be executed after executing the job here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_JOB_CUSTOM JOB=POSTJOB_CUSTOM_3

    # @@END DMEXPRESS_POST_JOB_CUSTOM 
   

    WriteExitStatus 3 $exitCode
}

WaitForAllTasks()
{
    # ************************************************************************
    # PURPOSE:
    # This routine waits for all tasks to finish, writes their output to
    # standard error and returns the most severe exit status.
    # ************************************************************************
    typeset mostSevereError=0
    typeset keepLooping=1
    typeset task
    typeset exitStatus
    while [[ $keepLooping -eq 1 ]]
    do
        sleep 1
        keepLooping=0
        task=1
        while [[ $task -le 3 ]]
        do
            if [ -f "$tempDir/$$_${jobName}_task$task.exit" ]
            then
                if [ ! -f "$tempDir/$$_${jobName}_task$task.written" ]
                then
                    cat "$tempDir/$$_${jobName}_task$task.out" 1>&2
                    exitStatus=`cat "$tempDir/$$_${jobName}_task$task.exit"`
                    GetMostSevereError $mostSevereError $exitStatus
                    mostSevereError=$?
                    touch "$tempDir/$$_${jobName}_task$task.written"
                    if [[ $exitStatus -eq 111 ]]
                    then
                        kill -TERM 0
                    fi
                fi
            else
                if [ -f "$tempDir/$$_${jobName}_job.abort" ]
                then
                    if [ -f "$tempDir/$$_${jobName}_task$task.temp" ]
                    then
                        keepLooping=1
                    fi
                else
                    keepLooping=1
                fi
            fi
            ((task=$task+1))
        done
    done
    return $mostSevereError
}

GetMostSevereError()
{
    # ************************************************************************
    # PURPOSE:
    # This routine gets the most severe error out of the 2 DMExpress exit
    # status passed.
    # ************************************************************************
    status1=$1
    status2=$2
    if [[ $status1 -gt $status2 ]]
    then
        return $status1
    else
        return $status2
    fi
}

CleanUp()
{
    # ************************************************************************
    # PURPOSE:
    # To clean up temporary resources used by the job
    # ************************************************************************
    typeset tempDir=$1
    rm -f "$tempDir/$$_${jobName}_job.abort"
    rm -f "$tempDir/$$_${jobName}_task1.exit"
    rm -f "$tempDir/$$_${jobName}_task1.out"
    rm -f "$tempDir/$$_${jobName}_task1.written"
    rm -f "$tempDir/$$_${jobName}_task1.temp"
    rm -f "$tempDir/$$_${jobName}_task2.exit"
    rm -f "$tempDir/$$_${jobName}_task2.out"
    rm -f "$tempDir/$$_${jobName}_task2.written"
    rm -f "$tempDir/$$_${jobName}_task2.temp"
    rm -f "$tempDir/$$_${jobName}_task3.exit"
    rm -f "$tempDir/$$_${jobName}_task3.out"
    rm -f "$tempDir/$$_${jobName}_task3.written"
    rm -f "$tempDir/$$_${jobName}_task3.temp"
}


# ************************************************************************
# PURPOSE:
# The main routine that executes the job.
# 
# TO DO:
# Modify this function as indicated in the body of the script to add 
# custom steps that should be executed before and after the execution 
# of the job.
# ************************************************************************

# Job name
jobName=`basename "$0" | cut -f -1 -d .`

# Temporary directory
tempDir=`DMXGetTempDir`
CleanUp $tempDir

# Trap signals and do clean-up
trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM


# TO DO: Insert the custom steps to be executed prior to running the job 
# between the @@START and @@END blocks
# @@START DMEXPRESS_PRE_JOB_CUSTOM

# @@END DMEXPRESS_PRE_JOB_CUSTOM

# Create temporary named pipes

# Create user-specified named pipes if they do not exist

# Start in parallel
ExecuteJob_1 2> $tempDir/$$_${jobName}_task1.out 1>&2 & \
ExecuteTask_2 2> $tempDir/$$_${jobName}_task2.out 1>&2 & \
ExecuteJob_3 2> $tempDir/$$_${jobName}_task3.out 1>&2 & \

# Wait for tasks to finish
WaitForAllTasks
mostSevereError=$?
if [ -f "$tempDir/$$_${jobName}_job.abort" ]
then
    mostSevereError=111
fi

# TO DO: Insert the custom steps to be executed after running the job 
# between the @@START and @@END blocks
# @@START DMEXPRESS_POST_JOB_CUSTOM

# @@END DMEXPRESS_POST_JOB_CUSTOM

# Free resources
wait
CleanUp $tempDir

# Return most severe error 
exit $mostSevereError



#***********************************************************************************
# Important Note: The following lines are used by DMExpress to store job specific 
# information. Do NOT delete or modify this section as it is exclusively used by 
# DMExpress.
# @@START DMEXPRESS_JOBEDITOR_APPSTREAM
#Version=8
#Release=9.0.0
#Language=kornshellscript
#Data=emkm4832fw7zvhp97euu5fmw72b5ueywy77x517wfkzzkz9sj8z0mh5ifbacnv83870zvsx6t00tzw03b6p2799pw6fuxsz04keb50t4ihxw6wikxdiwuk3exi3jsnf3mi0uum8s2bxm5uv0dxdrs4fzussawtmb7vm1ipn85hw1hk6j7dmi258ss8k3x8jnwkyfsu4fh7st0yi2b24kcjh3e62pye88brm4midtez8t8v5mjr2u10vpixc54ud46ej6492bkunk1syxbz7088zkpttw8d2wsk56upmxjy63efsnt5f8sznsei4x9xmtsurcty2h4r5afp6mtuzyt24mi2c6x4knbb9ctvu988cvy8f1thts4s406h41t1yn43t80t87rfv77dape150c9udrp2jw0zxs40hht67ruivv27d9zya2txih6eysdicr79csfa8vzhxm7ztw8k77k8s0r9t3rycepz7n0ifrf0d78w06n7w3u26i7ntd8x129n7jpin41pe64fv7jws8bidf7y3rneyrm4063ud4xardjdd5itmnpe5z6mk4xf0z62htjvvmh6fu72d7w1n7vb65i98cr8e31xyzrv3fywni69czbh7wi7vtzua5p0eht412mdn4h2y85wm2fcdk8jiahai6vf5fc9pd4dtb6cf6cnw32pm1i40243z4c442bcrdzphyv7iz8e01vkyhnvu5k0dr49ncy3u5e4unsskekkb7fz3b4bp9kt3pv79e3akczjh6aij05pdb1h06rs8wi1nez16zydtsfwdrsa84afmv6v8a2df9n4zc5634zjrje48hum0rfh755xkkujyz14f2wufd9c731mfwbur94r0hbxtfjfxb2pn7atytdc2tzyiry219cynhkh8cnrsyfzdvmbij3a8yh40ejwpxe0j6aeuru1xzvmpnh0wbf42cp2ait9sj3db19e6td45pewd2m7yxdm3n9irr9dbmiesw68ssi9xr8ke6x8s2d61bpwnjbu2f77tyb8xjvsdmutxnw83761uhkknjnmrhs2068pcjp9ja0ae8uru1jf37me2w584083rxu6h6977e8knjrt7dak60k46tk0f7zhfifx0a
# @@END DMEXPRESS_JOBEDITOR_APPSTREAM
#***********************************************************************************

