#!/bin/ksh
# *****************************************************************************
#  
# Copyright (c) @@CURRENT_YEAR Syncsort Inc.
#
# This file contains proprietary and confidential material, and is only for use
# by the lessees of the DMExpress proprietary software system.
#
#
# KornShell job script generated by DMExpress
#   
# Version: 9.0.0
# Date:    Friday, October 28, 2016 3:32:06 AM
# Note:
# 1.       In order to run this job script from the command line, execute the
#          command:
#
#              dmxjob /run job_name.dxj
#
#          where "job_name.dxj" is the name of this file.
#
# 2.       You must have Korn Shell (ksh) installed.
#
# 3.       You may customize portions of the script to add custom steps to the
#          job.
#
# 4.       If you run this script from the command line, DMExpress messages
#          are sent to standard error by default.
#
# 5.       If you run this job script from another script, the parent script
#          should start dmxjob in a separate process group. In Korn Shell
#          this can be done as follows:
#
#              set -m
#              dmxjob /run job_name.dxj &
#              set +m
#              wait $!
#
#          This will prevent the parent script from being killed if an error
#          occurs and the DMExpress job script must clean up. For more
#          information, consult the documentation for your shell.
#
# *****************************************************************************

# Import DMExpress shell functions
. DMExpress.ksh

# Save a copy of the process PATH
savedProcessPath=$PATH

WaitForTask()
{
    # ************************************************************************
    # PURPOSE:
    # This routine waits for a given task to finish.
    # ************************************************************************
    typeset task=$1
    while [ ! -f "$tempDir/$$_${jobName}_task$task.exit" ]
    do
        sleep 1
    done
}

WriteExitStatus()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the exit status of a task to a temporary file.
    # ************************************************************************
    typeset task=$1
    typeset status=$2
    if [[ $status -eq 111 ]]
    then
        touch "$tempDir/$$_${jobName}_job.abort"
    fi
    echo $status > $tempDir/$$_${jobName}_task$task.exit
}

WriteTaskHeader()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the task header text.
    # ************************************************************************
    typeset taskTitle="$1"
    echo "" 1>&2
    echo "************************ BEGIN TASK $taskTitle ************************" 1>&2
}

WriteTaskFooter()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the task footer text.
    # ************************************************************************
    typeset taskTitle="$1"
    echo "************************ END TASK $taskTitle   ************************" 1>&2
}

CreateNamedPipe()
{
    # ************************************************************************
    # PURPOSE:
    # This routine creates a named pipe if it does not already exist.
    # ************************************************************************
    typeset pipeName="$1"
    mknod "$pipeName" p 2>/dev/null || \
    mkfifo "$pipeName" 2>/dev/null
    if [[ $? -eq 0 ]]
    then
        return 1
    else
        return 0
    fi
}

CreateTemporaryNamedPipe()
{
    # ************************************************************************
    # PURPOSE:
    # This routine creates a named pipe
    # ************************************************************************
    typeset pipeName="$1"
    mknod "$pipeName" p 2>/dev/null || \
    mkfifo "$pipeName" 2>/dev/null || \
    ( echo "Could not create named pipe $pipeName" 1>&2 ; \
      touch "$tempDir/$$_${jobName}_job.abort" )
}

ConnectInput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input of a DMExpress task
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
        if [[ $? -eq 111 ]]
        then
            echo "DMXGetStandardInputIndex call failed" 1>&2
            return $?
        fi
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Previous task $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectInputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input file of a DMExpress task as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Input file $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectJoinedInput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input of a DMExpress task that is a join
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex

    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetStandardInputIndex call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetStandardInputIndex call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    echo "Previous task $connectionLabel not found in task" 1>&2
    return 111
}

ConnectJoinedInputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input file of a DMExpress task that is a join
    # as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex

    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    echo "Inputfile $connectionLabel not found in task" 1>&2
    return 111
}

ConnectOutput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an output of a DMExpress task
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetFollowingTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetFollowingTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        connectionIndex=`DMXGetStandardOutputIndex $applicationID 2>/dev/null`
        if [[ $? -eq 111 ]]
        then
            echo "DMXGetStandardOutputIndex call failed" 1>&2
            return $?
        fi
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Following task $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetTargetFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectOutputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an output file of a DMExpress task as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetOutputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetOutputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Output file $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetTargetFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ExecuteTask_1()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes task Core Table Load.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the task.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task1.temp"

    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 1 111 ; return
    fi

    
    WriteTaskHeader "Core Table Load"
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task1.temp" 1>&2
        WriteTaskFooter "Core Table Load" ; WriteExitStatus 1 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the task here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_TASK_CUSTOM TASK=PRETASK_CUSTOM_1

    # @@END DMEXPRESS_PRE_TASK_CUSTOM

    
    # Prepend the job directory to the process environment PATH
    PATH=$DMXJobDirectory:$PATH
    export PATH

    # Run custom task command
    exitCode=0
    "$SCRIPTDIR/ETL_BTEQ_Runner.sh" HDW_Ref_Employee_Goal_Report.sql

    # Save exit status of the custom task
    CUSTOM_TASK_RETURN_CODE=$?

    # Check if the return code of the custom command denotes success
    if [ "$CUSTOM_TASK_RETURN_CODE" -eq 0 ]
    then
        typeset timestamp=`date +"%m/%d/%Y %H:%M:%S"`
        echo "$timestamp - Custom task has completed successfully with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
    else
        echo "Custom task has failed with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
        exitCode=111
    fi
    
    # Restore the saved value of the process environment PATH
    PATH=$savedProcessPath
    export PATH

    # TO DO: Insert the custom steps to be executed after executing the task here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_TASK_CUSTOM TASK=POSTTASK_CUSTOM_1

    # @@END DMEXPRESS_POST_TASK_CUSTOM 
   

    WriteTaskFooter "Core Table Load"
    WriteExitStatus 1 $exitCode
}

WaitForAllTasks()
{
    # ************************************************************************
    # PURPOSE:
    # This routine waits for all tasks to finish, writes their output to
    # standard error and returns the most severe exit status.
    # ************************************************************************
    typeset mostSevereError=0
    typeset keepLooping=1
    typeset task
    typeset exitStatus
    while [[ $keepLooping -eq 1 ]]
    do
        sleep 1
        keepLooping=0
        task=1
        while [[ $task -le 1 ]]
        do
            if [ -f "$tempDir/$$_${jobName}_task$task.exit" ]
            then
                if [ ! -f "$tempDir/$$_${jobName}_task$task.written" ]
                then
                    cat "$tempDir/$$_${jobName}_task$task.out" 1>&2
                    exitStatus=`cat "$tempDir/$$_${jobName}_task$task.exit"`
                    GetMostSevereError $mostSevereError $exitStatus
                    mostSevereError=$?
                    touch "$tempDir/$$_${jobName}_task$task.written"
                    if [[ $exitStatus -eq 111 ]]
                    then
                        kill -TERM 0
                    fi
                fi
            else
                if [ -f "$tempDir/$$_${jobName}_job.abort" ]
                then
                    if [ -f "$tempDir/$$_${jobName}_task$task.temp" ]
                    then
                        keepLooping=1
                    fi
                else
                    keepLooping=1
                fi
            fi
            ((task=$task+1))
        done
    done
    return $mostSevereError
}

GetMostSevereError()
{
    # ************************************************************************
    # PURPOSE:
    # This routine gets the most severe error out of the 2 DMExpress exit
    # status passed.
    # ************************************************************************
    status1=$1
    status2=$2
    if [[ $status1 -gt $status2 ]]
    then
        return $status1
    else
        return $status2
    fi
}

CleanUp()
{
    # ************************************************************************
    # PURPOSE:
    # To clean up temporary resources used by the job
    # ************************************************************************
    typeset tempDir=$1
    rm -f "$tempDir/$$_${jobName}_job.abort"
    rm -f "$tempDir/$$_${jobName}_task1.exit"
    rm -f "$tempDir/$$_${jobName}_task1.out"
    rm -f "$tempDir/$$_${jobName}_task1.written"
    rm -f "$tempDir/$$_${jobName}_task1.temp"
}


# ************************************************************************
# PURPOSE:
# The main routine that executes the job.
# 
# TO DO:
# Modify this function as indicated in the body of the script to add 
# custom steps that should be executed before and after the execution 
# of the job.
# ************************************************************************

# Job name
jobName=`basename "$0" | cut -f -1 -d .`

# Temporary directory
tempDir=`DMXGetTempDir`
CleanUp $tempDir

# Trap signals and do clean-up
trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM


# TO DO: Insert the custom steps to be executed prior to running the job 
# between the @@START and @@END blocks
# @@START DMEXPRESS_PRE_JOB_CUSTOM

# @@END DMEXPRESS_PRE_JOB_CUSTOM

# Create temporary named pipes

# Create user-specified named pipes if they do not exist

# Start in parallel
ExecuteTask_1 2> $tempDir/$$_${jobName}_task1.out 1>&2 & \

# Wait for tasks to finish
WaitForAllTasks
mostSevereError=$?
if [ -f "$tempDir/$$_${jobName}_job.abort" ]
then
    mostSevereError=111
fi

# TO DO: Insert the custom steps to be executed after running the job 
# between the @@START and @@END blocks
# @@START DMEXPRESS_POST_JOB_CUSTOM

# @@END DMEXPRESS_POST_JOB_CUSTOM

# Free resources
wait
CleanUp $tempDir

# Return most severe error 
exit $mostSevereError



#***********************************************************************************
# Important Note: The following lines are used by DMExpress to store job specific 
# information. Do NOT delete or modify this section as it is exclusively used by 
# DMExpress.
# @@START DMEXPRESS_JOBEDITOR_APPSTREAM
#Version=8
#Release=9.0.0
#Language=kornshellscript
#Data=z2v4ve8bn31b71aekjfs5sf7k373yp7rj28usptv7d24ypedaw5z2fnuxvxr8rfj5yk7tzpitj83etudwe7rwnpsjh545xdmd7uz7bkkjivaw20nxwpr556zmx5s19vxshknsxsbxxj9f7ts3dj72excj1uvtik2hkvdhx8ceavh54c96a3rec65fcuhwit70b6zbkf98uzz8at5peat4vmijjx9imkwbnn88hh32iu32yv49h4n2ihrw0hw3jx3u9a87krkh1v64f80zdjbpnc5844iwwxfcupmse3d3ndau2tk7u46h9bt22ea4awanuu3debcauau0ieeffdbeypuwen1tm7sr94kmec1wax07h02ew4jmvht6danwb1z8nzi03j46nfxw08eeuk340m7jvuiyd6u7jthfda37972dijhdrduekx9j91jb5wke6vbe9r69z1ffvp0s75ajrxr0zysmd68teta8nb3t9bwcffxu1kxxfeivynirhkdhi85xrv45jn67ytt8nzjx09xjevr3e6460475a8c
# @@END DMEXPRESS_JOBEDITOR_APPSTREAM
#***********************************************************************************

