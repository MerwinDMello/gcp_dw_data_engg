#!/bin/ksh
# *****************************************************************************
#  
# Copyright (c) @@CURRENT_YEAR Syncsort Inc.
#
# This file contains proprietary and confidential material, and is only for use
# by the lessees of the DMExpress proprietary software system.
#
#
# KornShell job script generated by DMExpress
#   
# Version: 9.7.0
# Date:    Friday, February 14, 2020 4:26:46 PM
# Note:
# 1.       In order to run this job script from the command line, execute the
#          command:
#
#              dmxjob /run job_name.dxj
#
#          where "job_name.dxj" is the name of this file.
#
# 2.       You must have Korn Shell (ksh) installed.
#
# 3.       You may customize portions of the script to add custom steps to the
#          job.
#
# 4.       If you run this script from the command line, DMExpress messages
#          are sent to standard error by default.
#
# 5.       If you run this job script from another script, the parent script
#          should start dmxjob in a separate process group. In Korn Shell
#          this can be done as follows:
#
#              set -m
#              dmxjob /run job_name.dxj &
#              set +m
#              wait $!
#
#          This will prevent the parent script from being killed if an error
#          occurs and the DMExpress job script must clean up. For more
#          information, consult the documentation for your shell.
#
# *****************************************************************************

# Import DMExpress shell functions
. DMExpress.ksh

# Save a copy of the process PATH
savedProcessPath=$PATH

WaitForTask()
{
    # ************************************************************************
    # PURPOSE:
    # This routine waits for a given task to finish.
    # ************************************************************************
    typeset task=$1
    while [ ! -f "$tempDir/$$_${jobName}_task$task.exit" ]
    do
        sleep 1
    done
}

WriteExitStatus()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the exit status of a task to a temporary file.
    # ************************************************************************
    typeset task=$1
    typeset status=$2
    if [[ $status -eq 111 ]]
    then
        touch "$tempDir/$$_${jobName}_job.abort"
    fi
    echo $status > $tempDir/$$_${jobName}_task$task.exit
}

WriteTaskHeader()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the task header text.
    # ************************************************************************
    typeset taskTitle="$1"
    echo "" 1>&2
    echo "************************ BEGIN TASK $taskTitle ************************" 1>&2
}

WriteTaskFooter()
{
    # ************************************************************************
    # PURPOSE:
    # This routine writes the task footer text.
    # ************************************************************************
    typeset taskTitle="$1"
    echo "************************ END TASK $taskTitle   ************************" 1>&2
}

CreateNamedPipe()
{
    # ************************************************************************
    # PURPOSE:
    # This routine creates a named pipe if it does not already exist.
    # ************************************************************************
    typeset pipeName="$1"
    mknod "$pipeName" p 2>/dev/null || \
    mkfifo "$pipeName" 2>/dev/null
    if [[ $? -eq 0 ]]
    then
        return 1
    else
        return 0
    fi
}

CreateTemporaryNamedPipe()
{
    # ************************************************************************
    # PURPOSE:
    # This routine creates a named pipe
    # ************************************************************************
    typeset pipeName="$1"
    mknod "$pipeName" p 2>/dev/null || \
    mkfifo "$pipeName" 2>/dev/null || \
    ( echo "Could not create named pipe $pipeName" 1>&2 ; \
      touch "$tempDir/$$_${jobName}_job.abort" )
}

ConnectInput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input of a DMExpress task
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
        if [[ $? -eq 111 ]]
        then
            echo "DMXGetStandardInputIndex call failed" 1>&2
            return $?
        fi
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Previous task $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectInputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input file of a DMExpress task as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Input file $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectJoinedInput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input of a DMExpress task that is a join
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex

    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetPreviousTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetPreviousTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetStandardInputIndex call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetStandardInputIndex $applicationID 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetStandardInputIndex call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    echo "Previous task $connectionLabel not found in task" 1>&2
    return 111
}

ConnectJoinedInputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an input file of a DMExpress task that is a join
    # as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex

    DMXSelectJoinSide "$applicationID" 1 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    DMXSelectJoinSide "$applicationID" 2 2>/dev/null
    if [[ $? -eq 111 ]]
    then
        echo "Task is not a join" 1>&2
        return $?
    fi
    connectionIndex=`DMXGetInputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetInputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -ne 0 ]]
    then
        DMXSetSourceFile "$applicationID" "$fileName" "$connectionIndex"
        return $?
    fi    
    echo "Inputfile $connectionLabel not found in task" 1>&2
    return 111
}

ConnectOutput()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an output of a DMExpress task
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetFollowingTaskIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetFollowingTaskIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        connectionIndex=`DMXGetStandardOutputIndex $applicationID 2>/dev/null`
        if [[ $? -eq 111 ]]
        then
            echo "DMXGetStandardOutputIndex call failed" 1>&2
            return $?
        fi
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Following task $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetTargetFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ConnectOutputFileAsDirectFlow()
{
    # ************************************************************************
    # PURPOSE:
    # This routine connects an output file of a DMExpress task as a direct flow
    # ************************************************************************
    typeset applicationID="$1"
    typeset connectionLabel="$2"
    typeset fileName="$3"
    typeset connectionIndex
    connectionIndex=`DMXGetOutputFileIndexByLabel $applicationID $connectionLabel 2>/dev/null`
    if [[ $? -eq 111 ]]
    then
        echo "DMXGetOutputFileIndexByLabel call failed" 1>&2
        return $?
    fi
    if [[ $connectionIndex -eq 0 ]]
    then
        echo "Output file $connectionLabel not found in task" 1>&2
        return 111
    else
        DMXSetTargetFile "$applicationID" "$fileName" "$connectionIndex"
    fi    
}

ExecuteJob_1()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes job AC_REL_TD_EXP.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the job.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task1.temp"

    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 1 111 ; return
    fi

    
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task1.temp" 1>&2
        WriteTaskFooter "AC_REL_TD_EXP" ; WriteExitStatus 1 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the job here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_JOB_CUSTOM JOB=PREJOB_CUSTOM_1

    # @@END DMEXPRESS_PRE_JOB_CUSTOM

    
    # Execute DMX job
    exitCode=0
    dmxjob /RUN "$DMXJobDirectory/../../SharedJobs/AC_REL_TD_EXP/AC_REL_TD_EXP.dxj"
    exitCode=$?

    # TO DO: Insert the custom steps to be executed after executing the job here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_JOB_CUSTOM JOB=POSTJOB_CUSTOM_1

    # @@END DMEXPRESS_POST_JOB_CUSTOM 
   

    WriteExitStatus 1 $exitCode
}

ExecuteTask_2()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes task Work Table Load.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the task.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task2.temp"

    WaitForTask 1
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 2 111 ; return
    fi

    
    WriteTaskHeader "Work Table Load"
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task2.temp" 1>&2
        WriteTaskFooter "Work Table Load" ; WriteExitStatus 2 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the task here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_TASK_CUSTOM TASK=PRETASK_CUSTOM_2

    # @@END DMEXPRESS_PRE_TASK_CUSTOM

    
    # Prepend the job directory to the process environment PATH
    PATH=$DMXJobDirectory:$PATH
    export PATH

    # Run custom task command
    exitCode=0
    "$SCRIPTDIR/ETL_BTEQ_Runner.sh" HDW_TMS_Employee_Work_History_Wrk.sql

    # Save exit status of the custom task
    CUSTOM_TASK_RETURN_CODE=$?

    # Check if the return code of the custom command denotes success
    if [ "$CUSTOM_TASK_RETURN_CODE" -eq 0 ]
    then
        typeset timestamp=`date +"%m/%d/%Y %H:%M:%S"`
        echo "$timestamp - Custom task has completed successfully with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
    else
        echo "Custom task has failed with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
        exitCode=111
    fi
    
    # Restore the saved value of the process environment PATH
    PATH=$savedProcessPath
    export PATH

    # TO DO: Insert the custom steps to be executed after executing the task here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_TASK_CUSTOM TASK=POSTTASK_CUSTOM_2

    # @@END DMEXPRESS_POST_TASK_CUSTOM 
   

    WriteTaskFooter "Work Table Load"
    WriteExitStatus 2 $exitCode
}

ExecuteTask_3()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes task Core Table Load.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the task.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task3.temp"

    WaitForTask 2
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 3 111 ; return
    fi

    
    WriteTaskHeader "Core Table Load"
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task3.temp" 1>&2
        WriteTaskFooter "Core Table Load" ; WriteExitStatus 3 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the task here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_TASK_CUSTOM TASK=PRETASK_CUSTOM_3

    # @@END DMEXPRESS_PRE_TASK_CUSTOM

    
    # Prepend the job directory to the process environment PATH
    PATH=$DMXJobDirectory:$PATH
    export PATH

    # Run custom task command
    exitCode=0
    "$SCRIPTDIR/ETL_BTEQ_Runner.sh" HDW_TMS_Employee_Work_History_Core.sql

    # Save exit status of the custom task
    CUSTOM_TASK_RETURN_CODE=$?

    # Check if the return code of the custom command denotes success
    if [ "$CUSTOM_TASK_RETURN_CODE" -eq 0 ]
    then
        typeset timestamp=`date +"%m/%d/%Y %H:%M:%S"`
        echo "$timestamp - Custom task has completed successfully with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
    else
        echo "Custom task has failed with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
        exitCode=111
    fi
    
    # Restore the saved value of the process environment PATH
    PATH=$savedProcessPath
    export PATH

    # TO DO: Insert the custom steps to be executed after executing the task here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_TASK_CUSTOM TASK=POSTTASK_CUSTOM_3

    # @@END DMEXPRESS_POST_TASK_CUSTOM 
   

    WriteTaskFooter "Core Table Load"
    WriteExitStatus 3 $exitCode
}

ExecuteJob_4()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes job AC_REL_TD_ACT.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the job.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task4.temp"

    WaitForTask 3
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 4 111 ; return
    fi

    
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task4.temp" 1>&2
        WriteTaskFooter "AC_REL_TD_ACT" ; WriteExitStatus 4 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the job here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_JOB_CUSTOM JOB=PREJOB_CUSTOM_4

    # @@END DMEXPRESS_PRE_JOB_CUSTOM

    
    # Execute DMX job
    exitCode=0
    dmxjob /RUN "$DMXJobDirectory/../../SharedJobs/AC_REL_TD_ACT/AC_REL_TD_ACT.dxj"
    exitCode=$?

    # TO DO: Insert the custom steps to be executed after executing the job here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_JOB_CUSTOM JOB=POSTJOB_CUSTOM_4

    # @@END DMEXPRESS_POST_JOB_CUSTOM 
   

    WriteExitStatus 4 $exitCode
}

ExecuteTask_5()
{
    # ************************************************************************
    # PURPOSE:
    # This routine executes task Mismatch Check.
    # 
    # TO DO:
    # Modify this function as indicated in the body of the script to add 
    # custom steps that should be executed before and after the execution 
    # of the task.
    # ************************************************************************

    # Trap signals and do clean-up
    trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM
    touch "$tempDir/$$_${jobName}_task5.temp"

    WaitForTask 4
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        WriteExitStatus 5 111 ; return
    fi

    
    WriteTaskHeader "Mismatch Check"
    
    # Abort task if abort flag is raised
    if [ -f "$tempDir/$$_${jobName}_job.abort" ]
    then
        cat "$tempDir/$$_${jobName}_task5.temp" 1>&2
        WriteTaskFooter "Mismatch Check" ; WriteExitStatus 5 111 ; return
    fi


    # TO DO: Insert the custom steps to be executed before executing the task here 
    #        between @@START and @@END tags.    
    # @@START DMEXPRESS_PRE_TASK_CUSTOM TASK=PRETASK_CUSTOM_5

    # @@END DMEXPRESS_PRE_TASK_CUSTOM

    
    # Prepend the job directory to the process environment PATH
    PATH=$DMXJobDirectory:$PATH
    export PATH

    # Run custom task command
    exitCode=0
    "$MISMATCHDIR/Mismatch_HDW.sh" 

    # Save exit status of the custom task
    CUSTOM_TASK_RETURN_CODE=$?

    # Check if the return code of the custom command denotes success
    if [ "$CUSTOM_TASK_RETURN_CODE" -eq 0 ]
    then
        typeset timestamp=`date +"%m/%d/%Y %H:%M:%S"`
        echo "$timestamp - Custom task has completed successfully with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
    else
        echo "Custom task has failed with return code $CUSTOM_TASK_RETURN_CODE." 1>&2
        exitCode=111
    fi
    
    # Restore the saved value of the process environment PATH
    PATH=$savedProcessPath
    export PATH

    # TO DO: Insert the custom steps to be executed after executing the task here 
    #        between @@START and @@END tags.   
    # @@START DMEXPRESS_POST_TASK_CUSTOM TASK=POSTTASK_CUSTOM_5

    # @@END DMEXPRESS_POST_TASK_CUSTOM 
   

    WriteTaskFooter "Mismatch Check"
    WriteExitStatus 5 $exitCode
}

WaitForAllTasks()
{
    # ************************************************************************
    # PURPOSE:
    # This routine waits for all tasks to finish, writes their output to
    # standard error and returns the most severe exit status.
    # ************************************************************************
    typeset mostSevereError=0
    typeset keepLooping=1
    typeset task
    typeset exitStatus
    while [[ $keepLooping -eq 1 ]]
    do
        sleep 1
        keepLooping=0
        task=1
        while [[ $task -le 5 ]]
        do
            if [ -f "$tempDir/$$_${jobName}_task$task.exit" ]
            then
                if [ ! -f "$tempDir/$$_${jobName}_task$task.written" ]
                then
                    cat "$tempDir/$$_${jobName}_task$task.out" 1>&2
                    exitStatus=`cat "$tempDir/$$_${jobName}_task$task.exit"`
                    GetMostSevereError $mostSevereError $exitStatus
                    mostSevereError=$?
                    touch "$tempDir/$$_${jobName}_task$task.written"
                    if [[ $exitStatus -eq 111 ]]
                    then
                        kill -TERM 0
                    fi
                fi
            else
                if [ -f "$tempDir/$$_${jobName}_job.abort" ]
                then
                    if [ -f "$tempDir/$$_${jobName}_task$task.temp" ]
                    then
                        keepLooping=1
                    fi
                else
                    keepLooping=1
                fi
            fi
            ((task=$task+1))
        done
    done
    return $mostSevereError
}

GetMostSevereError()
{
    # ************************************************************************
    # PURPOSE:
    # This routine gets the most severe error out of the 2 DMExpress exit
    # status passed.
    # ************************************************************************
    status1=$1
    status2=$2
    if [[ $status1 -gt $status2 ]]
    then
        return $status1
    else
        return $status2
    fi
}

CleanUp()
{
    # ************************************************************************
    # PURPOSE:
    # To clean up temporary resources used by the job
    # ************************************************************************
    typeset tempDir=$1
    rm -f "$tempDir/$$_${jobName}_job.abort"
    rm -f "$tempDir/$$_${jobName}_task1.exit"
    rm -f "$tempDir/$$_${jobName}_task1.out"
    rm -f "$tempDir/$$_${jobName}_task1.written"
    rm -f "$tempDir/$$_${jobName}_task1.temp"
    rm -f "$tempDir/$$_${jobName}_task2.exit"
    rm -f "$tempDir/$$_${jobName}_task2.out"
    rm -f "$tempDir/$$_${jobName}_task2.written"
    rm -f "$tempDir/$$_${jobName}_task2.temp"
    rm -f "$tempDir/$$_${jobName}_task3.exit"
    rm -f "$tempDir/$$_${jobName}_task3.out"
    rm -f "$tempDir/$$_${jobName}_task3.written"
    rm -f "$tempDir/$$_${jobName}_task3.temp"
    rm -f "$tempDir/$$_${jobName}_task4.exit"
    rm -f "$tempDir/$$_${jobName}_task4.out"
    rm -f "$tempDir/$$_${jobName}_task4.written"
    rm -f "$tempDir/$$_${jobName}_task4.temp"
    rm -f "$tempDir/$$_${jobName}_task5.exit"
    rm -f "$tempDir/$$_${jobName}_task5.out"
    rm -f "$tempDir/$$_${jobName}_task5.written"
    rm -f "$tempDir/$$_${jobName}_task5.temp"
}


# ************************************************************************
# PURPOSE:
# The main routine that executes the job.
# 
# TO DO:
# Modify this function as indicated in the body of the script to add 
# custom steps that should be executed before and after the execution 
# of the job.
# ************************************************************************

# Job name
jobName=`basename "$0" | cut -f -1 -d .`

# Temporary directory
tempDir=`DMXGetTempDir`
CleanUp $tempDir

# Trap signals and do clean-up
trap "touch \"$tempDir/$$_${jobName}_job.abort\"" INT QUIT TERM


# TO DO: Insert the custom steps to be executed prior to running the job 
# between the @@START and @@END blocks
# @@START DMEXPRESS_PRE_JOB_CUSTOM

# @@END DMEXPRESS_PRE_JOB_CUSTOM

# Create temporary named pipes

# Create user-specified named pipes if they do not exist

# Start in parallel
ExecuteJob_1 2> $tempDir/$$_${jobName}_task1.out 1>&2 & \
ExecuteTask_2 2> $tempDir/$$_${jobName}_task2.out 1>&2 & \
ExecuteTask_3 2> $tempDir/$$_${jobName}_task3.out 1>&2 & \
ExecuteJob_4 2> $tempDir/$$_${jobName}_task4.out 1>&2 & \
ExecuteTask_5 2> $tempDir/$$_${jobName}_task5.out 1>&2 & \

# Wait for tasks to finish
WaitForAllTasks
mostSevereError=$?
if [ -f "$tempDir/$$_${jobName}_job.abort" ]
then
    mostSevereError=111
fi

# TO DO: Insert the custom steps to be executed after running the job 
# between the @@START and @@END blocks
# @@START DMEXPRESS_POST_JOB_CUSTOM

# @@END DMEXPRESS_POST_JOB_CUSTOM

# Free resources
wait
CleanUp $tempDir

# Return most severe error 
exit $mostSevereError



#***********************************************************************************
# Important Note: The following lines are used by DMExpress to store job specific 
# information. Do NOT delete or modify this section as it is exclusively used by 
# DMExpress.
# @@START DMEXPRESS_JOBEDITOR_APPSTREAM
#Version=8
#Release=9.7.0
#Language=kornshellscript
#Data=cd293zrna93ww3dysdjfyc1dx21y5awa7kwfjd7t8p2s423s6akrfmyerzwnv3f7ui18smrks9yii59vjb02wrye48tac61vyi3t3b3d0a7nw47fxk4wkjspyjciecn7vwz67wdtctam5y2s9vrsrvdkdfdbc4p11chpmmh62dde3y3hwh3ix2k0x17dm6k3u1kbs5kx3v71amn9m3im32e5chxkd8vd27iip098z4iwtm9ckwupupis1yv0dr7afv1hu9sf9r3hfp8psw2iksu4bz69j4dt252dvdh1r0s5ixn5h5c78e9mvx2ibyp2a16xypp2wr6d0v8tb5vku2hd9djdzbjw7dzu2em1cticx1cezfaunbu4ydikea42zi3j5ytw8991119z1f8iz9v1pdd7bhku24aud8hkpkxfnpdu0hw1yrku7sx2z5a59av1ivh15tvnp6n4c924c3shabiwr2j8i7zhym9tbtu0hdd3resbtp7is14h8ay4ezt0ccxayampfh70zwrdisa4fufxdi845umsre9xuxyuzb7hwcxiskiv3ufsks36vmcfip9m5d11sbuvx1zjhidpmz4mw9tmfke1bmavjdh8sd6u41e3rymt7whvw5isjwx8mkyn11iu73ht50zjk9nuyvkbyv5kh6yprrt33tvfscrx3hxmn3efdy3vz0rkec932n5x9ftjp5890iper2fcrxxjuxw7dpu2kkktu5k0wjr7h4hwwwj0xx7i4yja080pfu46kmvp1hhvc0f4ukcjsuxtveh9fm885b10mzb01xhrize1ezjvp15wc90mv6evizew87y17tnysv7nyxr6n8cdtfcawrdp8j21rw953cttx92d6ryzb1mm3pf1v9k3uc09b12zwupaty728n5ux5mpdmmk49uhnvzhf739k9nsnx5nk671szna7jnzdruzcb737fyi2cfr4x761b86mzweccbt9xrfzdbewxt02mfrfs4kmjykfn0bdcta1c6kt78m2wizuanfhp8jd90t1x41nb89nijbumwvikh2dktcwad9uv1zjr8hesmez936yyhevyd0z8hx2u3j0k9w8sfa2e0h7za987bz4fy17v9xwkh7wbdjfit9183hkshver4y3st3vzt8xet71481f91v5n65i1d9aae2v780k1z6a8kca9wciaj32ipi4ffiue8k04b1hjdmebbbyn6vhpuv1ben2n7hc312j8eyauytiybxnpjc5tmcs5db8dinxvk6vd81t0ubupi1vs8usrtrcfz49usf145ah61ziumvphfa8r33t8nrvi23t0c1um33yv8ttu9pdmd0miv9s6uz8y01hh83jym07ew2602utkvp7353nscxjjrj1z9re5afycnrynr67u4astamsd59t6ck2xizm0bbj6eab6e3k8zw3u8zmtrx4d4rk2hmsctu5myjauu7uh7ayu6es40idy58x22k84389nj82m5xcu9tas045udbj0i3pptxwpf5765730ppve7afmwkjmts72vc2kjzbivhwpp8x8hr2m7ht9e7ct6wrwk23y1u2bck8k7tju4uunckbji9d3u2n4tn2xrah8f3i30fwkz6bw92crwwnd7n80dk7kej6fk9yhu4auiv3wv0ec5vpnd8x64t406ra8niih9z8bcbe0zxyv3fx4hdy1iey3ixw1kifm3m3fdw0546nsd59zh62sn48cmwk18n5m5ddvuc568vvvjkw839t8j2uahnj2vdfiu8c5rink4bsk2dv6er599d0iky1ivi06iu4xnvh4hrdt7n1umkkkm1nmsvw5nj9r39f78fh7u2fn8autjeshh7y7n328be3j6tx0veupvnnyejn5kj85vneft6ka2c4jh4fv0rs64rapiaaf9hx47dbzt5acxam03mfv1bac3hcrd46yhd95v17zat4c9sk6w1z27kzwdfp51m1103aav12xiz2dvf4fvjd2np629a5ybdb02xnskhd
# @@END DMEXPRESS_JOBEDITOR_APPSTREAM
#***********************************************************************************

